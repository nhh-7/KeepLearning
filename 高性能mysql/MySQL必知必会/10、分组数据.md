#### 创建分组
	分组是在SELECT语句的GROUP BY子句中建立的。
	SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id;
	GROUP BY子句指示MySQL按vend_id排序并分组数据。这导致对每个vend_id而不是整个表计算num_prods一次。
	
	重要的规定
	GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，
	为数据分组提供更细致的控制。
	如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上
	进行汇总。换句话说，在建立分组时，指定的所有列都一起计算
	（所以不能从个别的列取回数据）。
	GROUP BY子句中列出的每个列都必须是检索列或有效的表达式
	（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在
	GROUP BY子句中指定相同的表达式。不能使用别名。
	除聚集计算语句外， SELECT语句中的每个列都必须在GROUP BY子
	句中给出。
	如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列
	中有多行NULL值，它们将分为一组。
	GROUP BY子句必须出现在WHERE子句之后， ORDER BY子句之前。

#### 过滤分组
	HAVING非常类似于WHERE。事实上，目前为止所学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是WHERE过滤行，而HAVING过滤分组。WHERE在数据分组前进行过滤， HAVING在数据分组后进行过滤。
	SELECT cust_id, COUNT(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(*) >= 2;

	SELECT vend_id, COUNT(*) AS num_prods FROM products WHERE prod_price >= 10 GROUP BY vend_id HAVING COUNT(*) >= 2;
	WHERE子句过滤所有prod_price至少为10的行。然后按vend_id分组数据， HAVING子句过滤计数为2或2以上的分组。

#### 分组和排序
	SELECT order_num, SUM(quantity*item_price) AS ordertotal
	FROM orderitems
	GROUP BY order_num
	HAVING SUM(quantity*item_price) >= 50
	ORDER BY ordertotal;
	
	GROUP BY子句用来按订单号（order_num列）分组数据，以便SUM(*)函数能够返回总计订单价格。HAVING子句过滤数据，使得只返回总计订单价格大于等于50的订单。最后，用ORDER BY子句对分组后的ordertotal进行排序输出。