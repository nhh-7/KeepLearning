	触发器是MySQL响应DELETE，INSERT，UPDATE语句而自动执行的一条MySQL语句，其他MySQL语句不支持触发器。

### 创建触发器
	在创建触发器时，需要给出4条信息：
	 唯一的触发器名；最好是在数据库范围内使用唯一的触发器名。
	 触发器关联的表；
	 触发器应该响应的活动（ DELETE、 INSERT或UPDATE）；
	 触发器何时执行（处理之前或之后）。

	CREATE TRIGGER newproduct AFTER INSERT ON products
	FOR EACH ROW SELECT 'Product added' INTO @txt;
	CREATE TRIGGER用来创建名为newproduct的新触发器。触发器可在一个操作发生之前或之后执行，这里给出了AFTER INSERT，所以此触发器将在INSERT语句成功执行后执行。这个触发器还指定FOR EACH ROW，因此代码对每个插入行执行。在这个例子中，文本Product added将对每个插入的行显示一次。

	触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条INSERT、 UPDATE和DELETE的之前和之后）。单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。

	触发器失败 如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败， MySQL将不执行AFTER触发器。

### 删除触发器
	DROP TRIGGER newproduct;
	触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建

### 使用触发器
##### INSERT触发器
	 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；
	 在BEFORE INSERT触发器中， NEW中的值也可以被更新（允许更改被插入的值）；
	 对于AUTO_INCREMENT列， NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。
	
	# INSERT触发器
	CREATE TRIGGER neworder AFTER INSERT ON orders
	FOR EACH ROW SELECT NEW.order_num INTO @new_order_num;
	在插入一个新订单到orders表时， MySQL生成一个新订单号并保存到order_num中。触发器从NEW. order_num取得这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成。对于orders的每次插入使用这个触发器将总是返回新的订单号。
	
	将BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据）。

##### DELETE触发器
	 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；
	 OLD中的值全都是只读的，不能更新。

##### UPDATE触发器
	UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点：
	 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（ UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；
	 在BEFORE UPDATE触发器中， NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；
	 OLD中的值全都是只读的，不能更新
	
	# UPDATE触发器
	CREATE TRIGGER updatetrigger BEFORE UPDATE ON vendors
	FOR EACH ROW SET NEW.vend_state = UPPER(NEW.vend_state);
	每次更新一个行时， NEW.vend_state中的值（将用来更新表行的值）都用Upper(NEW.vend_state)替换。这样使得无论更新语句中的值是大写还是小写，都将会变成大写然后更新到表中。




	 应该用触发器来保证数据的一致性（大小写、格式等）。在触发器中执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关。
	 触发器的一种非常有意义的使用是创建审计跟踪。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易。
	 遗憾的是， MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。